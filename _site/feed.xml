<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>nocohub</title>
    <description>機械学習,データ解析,ディープラーニング,C/C++,Pyhton,Java,プログラミング
</description>
    <link>http://yourdomain.com/</link>
    <atom:link href="http://yourdomain.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 24 Jan 2017 23:13:22 +0900</pubDate>
    <lastBuildDate>Tue, 24 Jan 2017 23:13:22 +0900</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>最長共通部分列問題</title>
        <description>&lt;h2 id=&quot;lcs-longest-common-subsequence&quot;&gt;最長共通部分列問題(LCS: Longest Common Subsequence)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;２つの文字列s&lt;sub&gt;1&lt;/sub&gt;s&lt;sub&gt;2&lt;/sub&gt;…s&lt;sub&gt;n&lt;/sub&gt;と
t&lt;sub&gt;1&lt;/sub&gt;t&lt;sub&gt;2&lt;/sub&gt;…t&lt;sub&gt;m&lt;/sub&gt;が与えられる。
これら２つの共通部分列の長さを求めよ。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;dp[i][j] := s&lt;sub&gt;1&lt;/sub&gt;…s&lt;sub&gt;i&lt;/sub&gt;とt&lt;sub&gt;1&lt;/sub&gt;…t&lt;sub&gt;j&lt;/sub&gt;に対するLCSの長さ&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;とすると、共通部分は、&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;s&lt;sub&gt;1&lt;/sub&gt;…s&lt;sub&gt;i&lt;/sub&gt;とt&lt;sub&gt;1&lt;/sub&gt;…t&lt;sub&gt;j&lt;/sub&gt;に対する共通部分列の後ろにs&lt;sub&gt;i+1&lt;/sub&gt;をつなげたもの&lt;/li&gt;
  &lt;li&gt;s&lt;sub&gt;1&lt;/sub&gt;…s&lt;sub&gt;i&lt;/sub&gt;とt&lt;sub&gt;1&lt;/sub&gt;…t&lt;sub&gt;j+1&lt;/sub&gt;に対する共通部分列&lt;/li&gt;
  &lt;li&gt;s&lt;sub&gt;1&lt;/sub&gt;…s&lt;sub&gt;i+1&lt;/sub&gt;とt&lt;sub&gt;1&lt;/sub&gt;…t&lt;sub&gt;j&lt;/sub&gt;に対する共通部分列&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;のどれかとなる。以下、C++のコード。&lt;/p&gt;

&lt;p&gt;```c++
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;&lt;/string&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;h1 id=&quot;define-maxn-1000&quot;&gt;define MAX_N 1000&lt;/h1&gt;
&lt;p&gt;#define MAX_M 1000&lt;/p&gt;

&lt;p&gt;int n, m;
string s, t;&lt;/p&gt;

&lt;p&gt;int dp[MAX_N+1][MAX_M+1];&lt;/p&gt;

&lt;p&gt;void solve() {
    for (int i=0; i&amp;lt;n; ++i) {
        for (int j=0; j&amp;lt;m; ++j) {
            if (s[i] == t[j]) {
                dp[i+1][j+1] = dp[i][j] + 1;
            }
            else {
                dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j]);
            }
        }
    }
}&lt;/p&gt;

&lt;p&gt;int main() {
    cin » n » m;
    cin » s » t;
    solve();
    cout « dp[n][m] « endl;
}
```&lt;/p&gt;

&lt;p&gt;計算量はO(nm)&lt;/p&gt;
</description>
        <pubDate>Mon, 23 Jan 2017 21:00:00 +0900</pubDate>
        <link>http://yourdomain.com/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/2017/01/23/lcs-copy.html</link>
        <guid isPermaLink="true">http://yourdomain.com/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/2017/01/23/lcs-copy.html</guid>
        
        
        <category>アルゴリズム</category>
        
      </item>
    
      <item>
        <title>最長増加部分列問題</title>
        <description>&lt;h2 id=&quot;lis-longest-increasing-subsequence&quot;&gt;最長増加部分列問題(LIS: Longest Increasing Subsequence)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;長さnの数列a&lt;sub&gt;0&lt;/sub&gt;,a&lt;sub&gt;1&lt;/sub&gt;,…,a&lt;sub&gt;n-1&lt;/sub&gt;がある。
この数列の増加部分列うち、最長のものの長さを求めよ。
ただし、増加部分列とは、全てのi&amp;lt;jでa&lt;sub&gt;i&lt;/sub&gt;&amp;lt;a&lt;sub&gt;j&lt;/sub&gt;を満たす部分列のことを言う。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;漸化式を立ててみると、&lt;br /&gt;
&lt;strong&gt;dp[i] := 長さがi+1である増加部分列における最終要素の最小値(存在しない場合INF)&lt;/strong&gt;&lt;br /&gt;
となる。以下、C++のコード。&lt;/p&gt;

&lt;p&gt;```c++
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;&lt;/vector&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;h1 id=&quot;define-inf-1e9&quot;&gt;define INF 1e+9&lt;/h1&gt;
&lt;p&gt;#define MAX_N 1000&lt;/p&gt;

&lt;p&gt;int dp[MAX_N];
int n;
vector&lt;int&gt; a;&lt;/int&gt;&lt;/p&gt;

&lt;p&gt;void solve() {
    fill(dp, dp+n, INF);
    for (int i=0; i&amp;lt;n; ++i) {
        *lower_bound(dp, dp+n, a[i]) = a[i];
    }
    cout « lower_bound(dp, dp+n, INF) - dp « endl;
}&lt;/p&gt;

&lt;p&gt;int main() {
    cin » n;
    a.resize(n);
    for(int i=0; i&amp;lt;n; ++i) cin » a[i];
    solve();
}
```&lt;/p&gt;

&lt;p&gt;計算量はO(n log n).&lt;/p&gt;
</description>
        <pubDate>Mon, 23 Jan 2017 10:00:00 +0900</pubDate>
        <link>http://yourdomain.com/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/2017/01/23/lis-copy.html</link>
        <guid isPermaLink="true">http://yourdomain.com/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/2017/01/23/lis-copy.html</guid>
        
        
        <category>アルゴリズム</category>
        
      </item>
    
      <item>
        <title>ChainerでMNIST</title>
        <description>&lt;p&gt;Chainer1.19.0版MNISTのコード&lt;br /&gt;
多層パーセプトロンモデルを構築する.&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;ネットワークの構築&lt;/h3&gt;
&lt;p&gt;Chainerでは、Linearクラスで全結合層を構築していく.&lt;/p&gt;

&lt;p&gt;``` python
class MLP(chainer.Chain):
    def &lt;strong&gt;init&lt;/strong&gt;(self, n_units, n_out):
        super(MLP, self).&lt;strong&gt;init&lt;/strong&gt;(
            l1=L.Linear(None, n_units),
            l2=L.Linear(None, n_units),
            l3=L.Linear(None, n_out),
        )&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def __call__(self, x):
    h1 = F.relu(self.l1(x))
    h2 = F.relu(self.l2(h1))
    return self.l3(h2) ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;訓練用ネットワークの設定&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;ユニット数、ミニバッチサイズ、エポック数を決めておく.&lt;/li&gt;
  &lt;li&gt;オプティマイザを設定する.&lt;/li&gt;
  &lt;li&gt;データセットを読み込む.&lt;/li&gt;
  &lt;li&gt;trainerの初期設定をする.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;``` python
    unit = 1000
    batchsize = 100
    epoch = 20&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;model = L.Classifier(MLP(unit, 10))

optimizer = chainer.optimizers.Adam()
optimizer.setup(model)

train, test = chainer.datasets.get_mnist()
train_iter = chainer.iterators.SerialIterator(train, batchsize)
test_iter = chainer.iterators.SerialIterator(test, batchsize, repeat=False, shuffle=False)

updater = training.StandardUpdater(train_iter, optimizer)
trainer = training.Trainer(updater, (epoch, &#39;epoch&#39;), out=&#39;result&#39;)

trainer.extend(extensions.Evaluator(test_iter, model)) ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;表示の設定&lt;/h3&gt;

&lt;p&gt;学習経過の表示の設定, グラフの出力設定などを行う.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python
    trainer.extend(extensions.dump_graph(&#39;main/loss&#39;))
    trainer.extend(extensions.snapshot(), trigger=(epoch, &#39;epoch&#39;))
    trainer.extend(extensions.LogReport())
    trainer.extend(extensions.PrintReport(
        [&#39;epoch&#39;, &#39;main/loss&#39;, &#39;validation/main/loss&#39;,
         &#39;main/accuracy&#39;, &#39;validation/main/accuracy&#39;, &#39;elapsed_time&#39;]))
    trainer.extend(extensions.ProgressBar())
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;訓練の実行&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python
trainer.run()
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;本記事で使用したコードは&lt;a href=&quot;https://github.com/nocotan/chainer-example/blob/master/examples/mnist-mlp.py&quot;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;※追記&lt;br /&gt;
同サンプルの畳み込みニューラルネットワーク(CNN)版は&lt;a href=&quot;https://github.com/nocotan/chainer-example/blob/master/examples/mnist-cnn.py&quot;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 15 Jan 2017 05:07:00 +0900</pubDate>
        <link>http://yourdomain.com/chainer/%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92/2017/01/15/chainer-mnist-copy.html</link>
        <guid isPermaLink="true">http://yourdomain.com/chainer/%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92/2017/01/15/chainer-mnist-copy.html</guid>
        
        
        <category>Chainer</category>
        
        <category>機械学習</category>
        
      </item>
    
      <item>
        <title>潜在的意味解析における特異値分解</title>
        <description>&lt;p&gt;潜在的意味解析(Latent semantic analysis: LSA)は1988年に自然言語処理及び情報検索分野の技術として開発された.
当初、LSAは特異値分解(Singular value decomposition: SVD)によって定式化された.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;特異値分解&lt;/h2&gt;

&lt;p&gt;行列Xを $ X = USV^T $ を満たす行列U, S, Vへと分解する.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Sは対角行列で、対角要素は特異値と呼ばれる&lt;/li&gt;
  &lt;li&gt;U, S, Vの各列ベクトルを、特異値が大きい順にK個用いて、新たに行列 $ \tilde{U}, \tilde{S}, \tilde{V} $を作る&lt;/li&gt;
  &lt;li&gt;$ \tilde{X} = \tilde{U}\tilde{S}\tilde{V}^T $ とすることで $ \tilde{X} $ を得る.&lt;/li&gt;
  &lt;li&gt;ここで、$ \tilde{X} $ はXの低ランク近似行列(low rank approximation)である.&lt;/li&gt;
  &lt;li&gt;この時、行列のランクはKとなる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例として、以下に示すXについて特異値分解を試行する.&lt;/p&gt;

&lt;table&gt;
&lt;caption&gt;X&lt;/caption&gt;
&lt;tr&gt;&lt;th&gt;.&lt;/th&gt;&lt;th&gt;drive&lt;/th&gt;&lt;th&gt;automobile&lt;/th&gt;&lt;th&gt;car&lt;/th&gt;&lt;th&gt;play&lt;/th&gt;&lt;th&gt;music&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;文書1&lt;/th&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;文書2&lt;/th&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;文書3&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;文書4&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;h4 id=&quot;x&quot;&gt;行列X&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python
X = np.array([[2,3,0,0,0],[2,0,2,0,0],[0,0,0,2,2],[0,0,0,3,1])
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;例えば、行列Xにおいて、文書1のcarの出現頻度は0である.よって、この行列からcarを検索したとしても、文書1を得ることはできない.
同様に、automobileで検索したとしても、文書2を見つけることはできない.
そこで、特異値分解によって潜在的共起性を抽出する.&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;特異値分解&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python
U, S, V = np.linalg.svd(X, full_matrices=True)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;特異値分解を実行すると、以下の行列が得られる.&lt;/p&gt;

&lt;table&gt;
&lt;caption&gt;U&lt;/caption&gt;
&lt;tr&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;0.88&lt;/td&gt;&lt;td&gt;-0.48&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;0.48&lt;/td&gt;&lt;td&gt;0.88&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0.66&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;-0.75&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&amp;gt;&lt;td&gt;0.75&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;0.66&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;caption&gt;S&lt;/caption&gt;
&lt;tr&gt;&lt;td&gt;4.1&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;-0.0&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;3.9&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;2.4&lt;/td&gt;&lt;td&gt;-0.0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&amp;gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;0.9&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;caption&gt;V&lt;/caption&gt;
&lt;tr&gt;&lt;td&gt;7.1e-17&lt;/td&gt;&lt;td&gt;-4.7e-17&lt;/td&gt;&lt;td&gt;-7.1e-17&lt;/td&gt;&lt;td&gt;0.86&lt;/td&gt;&lt;td&gt;0.5&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0.69&lt;/td&gt;&lt;td&gt;0.67&lt;/td&gt;&lt;td&gt;0.25&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0.32&lt;/td&gt;&lt;td&gt;-0.6&lt;/td&gt;&lt;td&gt;0.73&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&amp;gt;&lt;td&gt;3.1e-16&lt;/td&gt;&lt;td&gt;-2.1e-16&lt;/td&gt;&lt;td&gt;-3.1e-16&lt;/td&gt;&lt;td&gt;0.5&lt;/td&gt;&lt;td&gt;-0.86&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&amp;gt;&lt;td&gt;0.63&lt;/td&gt;&lt;td&gt;-0.42&lt;/td&gt;&lt;td&gt;-0.63&lt;/td&gt;&lt;td&gt;-1.4e-16&lt;/td&gt;&lt;td&gt;4.1e-16&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-2&quot;&gt;低ランク近似行列&lt;/h3&gt;
&lt;p&gt;特異値が大きい順にK(=2)個抜き出す.&lt;/p&gt;

&lt;p&gt;```python
k = 2
U2 = U[:, :k]
S2 = np.diag(S)[:k, :k]
V2 = V[:k, :]&lt;/p&gt;

&lt;p&gt;X2 = (U2.dot(S2).dot(V2))
```&lt;/p&gt;

&lt;p&gt;こうして得られた $ \tilde{X} $ は以下のようになる.&lt;br /&gt;
※ここでは簡単のため、負の値を0とする.&lt;/p&gt;
&lt;table&gt;
&lt;caption&gt; $ \tilde{X} $ &lt;/caption&gt;
&lt;tr&gt;&lt;th&gt;.&lt;/th&gt;&lt;th&gt;drive&lt;/th&gt;&lt;th&gt;automobile&lt;/th&gt;&lt;th&gt;car&lt;/th&gt;&lt;th&gt;play&lt;/th&gt;&lt;th&gt;music&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;文書1&lt;/th&gt;&lt;td&gt;2.4&lt;/td&gt;&lt;td&gt;2.3&lt;/td&gt;&lt;td&gt;0.85&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;文書2&lt;/th&gt;&lt;td&gt;1.3&lt;/td&gt;&lt;td&gt;1.27&lt;/td&gt;&lt;td&gt;0.47&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;文書3&lt;/th&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;2.4&lt;/td&gt;&lt;td&gt;1.3&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;文書4&lt;/th&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;2.7&lt;/td&gt;&lt;td&gt;1.6&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;以上の表から、文書1,文書2共にautomobile,
carの要素が正の値を取っていることがわかる。つまりdriveという単語の共起性からこの二つの単語の潜在的共起性が抽出されたことがわかる.&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;このように、元の行列の低ランク近似行列を用いることで、文章において、(一見すると)共起していない単語の共起性を抽出することができる.
しかし、この手法では、特異値分解の特徴から、各トピックは互いに直行した概念となってしまう.したがって、この手法では多少似た性質を持つトピックを表現することができず、柔軟性に乏しい.&lt;br /&gt;
 以上の問題を解決するため、1998年以降、確率モデル、階層ベイズモデルによって再度定式化された.&lt;br /&gt;
以下に、本記事で用いたコードをまとめる.&lt;/p&gt;

&lt;p&gt;``` python
# -&lt;em&gt;- coding: utf-8 -&lt;/em&gt;-
import numpy as np&lt;/p&gt;

&lt;p&gt;X = np.array([[2,3,0,0,0],[2,0,2,0,0],[0,0,0,2,2],[0,0,0,3,1]])
U, S, V = np.linalg.svd(X)&lt;/p&gt;

&lt;p&gt;k = 2
U2 = U[:, :k]
S2 = np.diag(S)[:k, :k]
V2 = V[:k, :]
X2 = (U2.dot(S2).dot(V2))
print(X2)
```&lt;/p&gt;
</description>
        <pubDate>Fri, 13 Jan 2017 05:00:00 +0900</pubDate>
        <link>http://yourdomain.com/%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92/2017/01/13/lsa_svd-copy.html</link>
        <guid isPermaLink="true">http://yourdomain.com/%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92/2017/01/13/lsa_svd-copy.html</guid>
        
        
        <category>機械学習</category>
        
      </item>
    
      <item>
        <title>2017年に読んだ本</title>
        <description>&lt;p&gt;2017年に読んだ本を列挙.(随時更新)&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;機械学習関連&lt;/h3&gt;

&lt;h4 id=&quot;ithttpswwwamazoncojpdpb016q22ix2refdp-kindle-redirectencodingutf8btkr1&quot;&gt;&lt;a href=&quot;https://www.amazon.co.jp/dp/B016Q22IX2/ref=dp-kindle-redirect?_encoding=UTF8&amp;amp;btkr=1&quot;&gt;ITエンジニアのための機械学習理論入門&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&quot;httpswwwamazoncojpe38388e38394e38383e382afe383a2e38387e383abe381abe38288e3828be7b5b1e8a888e79a84e6bd9ce59ca8e6848fe591b3e8a7a3e69e90-e887aae784b6e8a880e8aa9ee587a6e79086e382b7e383aae383bce382ba-e4bd90e897a4e4b880e8aaa0dp4339027588&quot;&gt;&lt;a href=&quot;https://www.amazon.co.jp/%E3%83%88%E3%83%94%E3%83%83%E3%82%AF%E3%83%A2%E3%83%87%E3%83%AB%E3%81%AB%E3%82%88%E3%82%8B%E7%B5%B1%E8%A8%88%E7%9A%84%E6%BD%9C%E5%9C%A8%E6%84%8F%E5%91%B3%E8%A7%A3%E6%9E%90-%E8%87%AA%E7%84%B6%E8%A8%80%E8%AA%9E%E5%87%A6%E7%90%86%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA-%E4%BD%90%E8%97%A4%E4%B8%80%E8%AA%A0/dp/4339027588&quot;&gt;トピックモデルによる統計的潜在意味解析(自然言語処理シリーズ)&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&quot;httpwwwsaiensucojppagebookdetailsisbn978-4-7819-1388-9year2016&quot;&gt;&lt;a href=&quot;http://www.saiensu.co.jp/?page=book_details&amp;amp;ISBN=978-4-7819-1388-9&amp;amp;YEAR=2016&quot;&gt;自然言語処理概論&lt;/a&gt;&lt;/h4&gt;

&lt;h3 id=&quot;section-1&quot;&gt;アルゴリズム関連&lt;/h3&gt;

&lt;h4 id=&quot;httptatsu-zinecombooksprocon-challenge&quot;&gt;&lt;a href=&quot;http://tatsu-zine.com/books/procon-challenge&quot;&gt;プログラミングコンテストチャレンジブック&lt;/a&gt;&lt;/h4&gt;

&lt;h3 id=&quot;unix&quot;&gt;UNIX関連&lt;/h3&gt;

&lt;h4 id=&quot;linuxhacks100httpswwwamazoncojplinuxe382b5e383bce38390hackse28095e38397e383ade3818ce4bdbfe38186e38386e382afe3838be38383e382af-e38384e383bce383ab100e981b8-e383ade38396-e38395e383aae38383e382b1e383b3e382ace383bcdp487311151x&quot;&gt;&lt;a href=&quot;https://www.amazon.co.jp/Linux%E3%82%B5%E3%83%BC%E3%83%90Hacks%E2%80%95%E3%83%97%E3%83%AD%E3%81%8C%E4%BD%BF%E3%81%86%E3%83%86%E3%82%AF%E3%83%8B%E3%83%83%E3%82%AF-%E3%83%84%E3%83%BC%E3%83%AB100%E9%81%B8-%E3%83%AD%E3%83%96-%E3%83%95%E3%83%AA%E3%83%83%E3%82%B1%E3%83%B3%E3%82%AC%E3%83%BC/dp/487311151X&quot;&gt;LinuxサーバHacks―プロが使うテクニック&amp;amp;ツール100選&lt;/a&gt;&lt;/h4&gt;

&lt;h3 id=&quot;section-2&quot;&gt;テスト関連&lt;/h3&gt;

&lt;h4 id=&quot;httpswwwamazoncojpe3839ee382a4e383b3e38389e3839ee38383e38397e3818be38289e5a78be38281e3828be382bde38395e38388e382a6e382a7e382a2e38386e382b9e38388-e6b1a0e794b0-e69a81dp4774131318&quot;&gt;&lt;a href=&quot;https://www.amazon.co.jp/%E3%83%9E%E3%82%A4%E3%83%B3%E3%83%89%E3%83%9E%E3%83%83%E3%83%97%E3%81%8B%E3%82%89%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%83%86%E3%82%B9%E3%83%88-%E6%B1%A0%E7%94%B0-%E6%9A%81/dp/4774131318&quot;&gt;マインドマップから始めるソフトウェアテスト&lt;/a&gt;&lt;/h4&gt;

&lt;h3 id=&quot;section-3&quot;&gt;その他&lt;/h3&gt;

&lt;h4 id=&quot;pro-githttpsprogit-jagithubio&quot;&gt;&lt;a href=&quot;https://progit-ja.github.io/&quot;&gt;Pro Git&lt;/a&gt;&lt;/h4&gt;

&lt;h3 id=&quot;section-4&quot;&gt;論文&lt;/h3&gt;

&lt;h4 id=&quot;httpswwwjstagejstgojparticletjsai27427253pdf&quot;&gt;&lt;a href=&quot;https://www.jstage.jst.go.jp/article/tjsai/27/4/27_253/_pdf&quot;&gt;機械学習研究におけるプログラム開発と検証 - モンテカルロ法に基づく確率推論計算を例として&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&quot;recurrent-neural-networkhttpswwwjstagejstgojparticletjsai32132wii-epdf&quot;&gt;&lt;a href=&quot;https://www.jstage.jst.go.jp/article/tjsai/32/1/32_WII-E/_pdf&quot;&gt;Recurrent Neural Networkによるマイクロブログの投稿位置推定&lt;/a&gt;&lt;/h4&gt;
</description>
        <pubDate>Fri, 13 Jan 2017 01:07:00 +0900</pubDate>
        <link>http://yourdomain.com/%E6%9B%B8%E7%B1%8D/2017/01/13/books-copy.html</link>
        <guid isPermaLink="true">http://yourdomain.com/%E6%9B%B8%E7%B1%8D/2017/01/13/books-copy.html</guid>
        
        
        <category>書籍</category>
        
      </item>
    
      <item>
        <title>新設しました</title>
        <description>&lt;h2 id=&quot;github&quot;&gt;GitHubページを新設しました&lt;/h2&gt;
&lt;p&gt;どうぞよろしくお願いします。&lt;/p&gt;
</description>
        <pubDate>Fri, 13 Jan 2017 01:07:00 +0900</pubDate>
        <link>http://yourdomain.com/update/2017/01/13/renew-copy.html</link>
        <guid isPermaLink="true">http://yourdomain.com/update/2017/01/13/renew-copy.html</guid>
        
        
        <category>update</category>
        
      </item>
    
  </channel>
</rss>
